{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "256d8a1c-49a3-4d96-8685-b455a53eae49",
   "metadata": {},
   "outputs": [],
   "source": [
    "# -*- coding: utf-8 -*-\n",
    "# @Time : 20-6-4 下午4:19\n",
    "# @Author : zhuying\n",
    "# @Company : Minivision\n",
    "# @File : transform.py\n",
    "# @Software : PyCharm\n",
    "\n",
    "from __future__ import division\n",
    "import math\n",
    "import random\n",
    "from PIL import Image\n",
    "try:\n",
    "    import accimage\n",
    "except ImportError:\n",
    "    accimage = None\n",
    "import numpy as np\n",
    "import numbers\n",
    "import types\n",
    "\n",
    "from data_io import functional as F\n",
    "\n",
    "__all__ = [\"Compose\", \"ToTensor\", \"ToPILImage\", \"Normalize\", \"RandomHorizontalFlip\",\n",
    "           \"Lambda\", \"RandomResizedCrop\", \"ColorJitter\", \"RandomRotation\"]\n",
    "\n",
    "\n",
    "class Compose(object):\n",
    "    \"\"\"Composes several transforms together.\n",
    "\n",
    "    Args:\n",
    "        transforms (list of ``Transform`` objects): list of transforms to compose.\n",
    "\n",
    "    Example:\n",
    "        >>> transforms.Compose([\n",
    "        >>>     transforms.CenterCrop(10),\n",
    "        >>>     transforms.ToTensor(),\n",
    "        >>> ])\n",
    "    \"\"\"\n",
    "\n",
    "    def __init__(self, transforms):\n",
    "        self.transforms = transforms\n",
    "\n",
    "    def __call__(self, img):\n",
    "        for t in self.transforms:\n",
    "            img = t(img)\n",
    "        return img\n",
    "\n",
    "\n",
    "class ToTensor(object):\n",
    "\n",
    "    \"\"\"Convert a ``PIL Image`` or ``numpy.ndarray`` to tensor.\n",
    "\n",
    "    Converts a PIL Image or numpy.ndarray (H x W x C) in the range\n",
    "    [0, 255] to a torch.FloatTensor of shape (C x H x W) in the range [0.0, 1.0].\n",
    "    \"\"\"\n",
    "\n",
    "    def __call__(self, pic):\n",
    "        \"\"\"\n",
    "        Args:\n",
    "            pic (PIL Image or numpy.ndarray): Image to be converted to tensor.\n",
    "\n",
    "        Returns:\n",
    "            Tensor: Converted image.\n",
    "        \"\"\"\n",
    "        return F.to_tensor(pic)\n",
    "\n",
    "\n",
    "class Lambda(object):\n",
    "    \"\"\"Apply a user-defined lambda as a transform.\n",
    "\n",
    "    Args:\n",
    "        lambd (function): Lambda/function to be used for transform.\n",
    "    \"\"\"\n",
    "\n",
    "    def __init__(self, lambd):\n",
    "        assert isinstance(lambd, types.LambdaType)\n",
    "        self.lambd = lambd\n",
    "\n",
    "    def __call__(self, img):\n",
    "        return self.lambd(img)\n",
    "\n",
    "\n",
    "class ToPILImage(object):\n",
    "    \"\"\"Convert a tensor or an ndarray to PIL Image.\n",
    "\n",
    "    Converts a torch.*Tensor of shape C x H x W or a numpy ndarray of shape\n",
    "    H x W x C to a PIL Image while preserving the value range.\n",
    "\n",
    "    Args:\n",
    "        mode (`PIL.Image mode`_): color space and pixel depth of input data (optional).\n",
    "            If ``mode`` is ``None`` (default) there are some assumptions made about the input data:\n",
    "            1. If the input has 3 channels, the ``mode`` is assumed to be ``RGB``.\n",
    "            2. If the input has 4 channels, the ``mode`` is assumed to be ``RGBA``.\n",
    "            3. If the input has 1 channel, the ``mode`` is determined by the data type (i,e,\n",
    "            ``int``, ``float``, ``short``).\n",
    "\n",
    "    .. _PIL.Image mode: http://pillow.readthedocs.io/en/3.4.x/handbook/concepts.html#modes\n",
    "    \"\"\"\n",
    "    def __init__(self, mode=None):\n",
    "        self.mode = mode\n",
    "\n",
    "    def __call__(self, pic):\n",
    "        \"\"\"\n",
    "        Args:\n",
    "            pic (Tensor or numpy.ndarray): Image to be converted to PIL Image.\n",
    "\n",
    "        Returns:\n",
    "            PIL Image: Image converted to PIL Image.\n",
    "\n",
    "        \"\"\"\n",
    "        return F.to_pil_image(pic, self.mode)\n",
    "\n",
    "\n",
    "class Normalize(object):\n",
    "    \"\"\"Normalize an tensor image with mean and standard deviation.\n",
    "    Given mean: ``(M1,...,Mn)`` and std: ``(S1,..,Sn)`` for ``n`` channels, this transform\n",
    "    will normalize each channel of the input ``torch.*Tensor`` i.e.\n",
    "    ``input[channel] = (input[channel] - mean[channel]) / std[channel]``\n",
    "\n",
    "    Args:\n",
    "        mean (sequence): Sequence of means for each channel.\n",
    "        std (sequence): Sequence of standard deviations for each channel.\n",
    "    \"\"\"\n",
    "\n",
    "    def __init__(self, mean, std):\n",
    "        self.mean = mean\n",
    "        self.std = std\n",
    "\n",
    "    def __call__(self, tensor):\n",
    "        \"\"\"\n",
    "        Args:\n",
    "            tensor (Tensor): Tensor image of size (C, H, W) to be normalized.\n",
    "\n",
    "        Returns:\n",
    "            Tensor: Normalized Tensor image.\n",
    "        \"\"\"\n",
    "        return F.normalize(tensor, self.mean, self.std)\n",
    "\n",
    "\n",
    "class RandomHorizontalFlip(object):\n",
    "    \"\"\"Horizontally flip the given PIL Image randomly with a probability of 0.5.\"\"\"\n",
    "\n",
    "    def __call__(self, img):\n",
    "        \"\"\"\n",
    "        Args:\n",
    "            img (PIL Image): Image to be flipped.\n",
    "\n",
    "        Returns:\n",
    "            PIL Image: Randomly flipped image.\n",
    "        \"\"\"\n",
    "        if random.random() < 0.5:\n",
    "            return F.hflip(img)\n",
    "        return img\n",
    "\n",
    "\n",
    "class RandomResizedCrop(object):\n",
    "    \"\"\"Crop the given PIL Image to random size and aspect ratio.\n",
    "\n",
    "    A crop of random size (default: of 0.08 to 1.0) of the original size and a random\n",
    "    aspect ratio (default: of 3/4 to 4/3) of the original aspect ratio is made. This crop\n",
    "    is finally resized to given size.\n",
    "    This is popularly used to train the Inception networks.\n",
    "\n",
    "    Args:\n",
    "        size: expected output size of each edge\n",
    "        scale: range of size of the origin size cropped\n",
    "        ratio: range of aspect ratio of the origin aspect ratio cropped\n",
    "        interpolation: Default: PIL.Image.BILINEAR\n",
    "    \"\"\"\n",
    "\n",
    "    def __init__(self, size, scale=(0.08, 1.0), ratio=(3. / 4., 4. / 3.), interpolation=Image.BILINEAR):\n",
    "        if isinstance(size, tuple):\n",
    "            self.size = size\n",
    "        else:\n",
    "            self.size = (size, size)\n",
    "        self.interpolation = interpolation\n",
    "        self.scale = scale\n",
    "        self.ratio = ratio\n",
    "\n",
    "    @staticmethod\n",
    "    def get_params(img, scale, ratio):\n",
    "        \"\"\"Get parameters for ``crop`` for a random sized crop.\n",
    "\n",
    "        Args:\n",
    "            img (PIL Image): Image to be cropped.\n",
    "            scale (tuple): range of size of the origin size cropped\n",
    "            ratio (tuple): range of aspect ratio of the origin aspect ratio cropped\n",
    "\n",
    "        Returns:\n",
    "            tuple: params (i, j, h, w) to be passed to ``crop`` for a random\n",
    "                sized crop.\n",
    "        \"\"\"\n",
    "        for attempt in range(10):\n",
    "            area = img.size[0] * img.size[1]\n",
    "            target_area = random.uniform(*scale) * area\n",
    "            aspect_ratio = random.uniform(*ratio)\n",
    "\n",
    "            w = int(round(math.sqrt(target_area * aspect_ratio)))\n",
    "            h = int(round(math.sqrt(target_area / aspect_ratio)))\n",
    "\n",
    "            if random.random() < 0.5:\n",
    "                w, h = h, w\n",
    "\n",
    "            if w <= img.size[0] and h <= img.size[1]:\n",
    "                i = random.randint(0, img.size[1] - h)\n",
    "                j = random.randint(0, img.size[0] - w)\n",
    "                return i, j, h, w\n",
    "\n",
    "        # Fallback\n",
    "        w = min(img.size[0], img.size[1])\n",
    "        i = (img.size[1] - w) // 2\n",
    "        j = (img.size[0] - w) // 2\n",
    "        return i, j, w, w\n",
    "\n",
    "    def __call__(self, img):\n",
    "        \"\"\"\n",
    "        Args:\n",
    "            img (PIL Image): Image to be flipped.\n",
    "\n",
    "        Returns:\n",
    "            PIL Image: Randomly cropped and resize image.\n",
    "        \"\"\"\n",
    "        i, j, h, w = self.get_params(img, self.scale, self.ratio)\n",
    "        return F.resized_crop(img, i, j, h, w, self.size, self.interpolation)\n",
    "\n",
    "\n",
    "class ColorJitter(object):\n",
    "    \"\"\"Randomly change the brightness, contrast and saturation of an image.\n",
    "\n",
    "    Args:\n",
    "        brightness (float): How much to jitter brightness. brightness_factor\n",
    "            is chosen uniformly from [max(0, 1 - brightness), 1 + brightness].\n",
    "        contrast (float): How much to jitter contrast. contrast_factor\n",
    "            is chosen uniformly from [max(0, 1 - contrast), 1 + contrast].\n",
    "        saturation (float): How much to jitter saturation. saturation_factor\n",
    "            is chosen uniformly from [max(0, 1 - saturation), 1 + saturation].\n",
    "        hue(float): How much to jitter hue. hue_factor is chosen uniformly from\n",
    "            [-hue, hue]. Should be >=0 and <= 0.5.\n",
    "    \"\"\"\n",
    "    def __init__(self, brightness=0, contrast=0, saturation=0, hue=0):\n",
    "        self.brightness = brightness\n",
    "        self.contrast = contrast\n",
    "        self.saturation = saturation\n",
    "        self.hue = hue\n",
    "\n",
    "    @staticmethod\n",
    "    def get_params(brightness, contrast, saturation, hue):\n",
    "        \"\"\"Get a randomized transform to be applied on image.\n",
    "\n",
    "        Arguments are same as that of __init__.\n",
    "\n",
    "        Returns:\n",
    "            Transform which randomly adjusts brightness, contrast and\n",
    "            saturation in a random order.\n",
    "        \"\"\"\n",
    "        transforms = []\n",
    "        if brightness > 0:\n",
    "            brightness_factor = np.random.uniform(max(0, 1 - brightness), 1 + brightness)\n",
    "            transforms.append(Lambda(lambda img: F.adjust_brightness(img, brightness_factor)))\n",
    "\n",
    "        if contrast > 0:\n",
    "            contrast_factor = np.random.uniform(max(0, 1 - contrast), 1 + contrast)\n",
    "            transforms.append(Lambda(lambda img: F.adjust_contrast(img, contrast_factor)))\n",
    "\n",
    "        if saturation > 0:\n",
    "            saturation_factor = np.random.uniform(max(0, 1 - saturation), 1 + saturation)\n",
    "            transforms.append(Lambda(lambda img: F.adjust_saturation(img, saturation_factor)))\n",
    "\n",
    "        if hue > 0:\n",
    "            hue_factor = np.random.uniform(-hue, hue)\n",
    "            transforms.append(Lambda(lambda img: F.adjust_hue(img, hue_factor)))\n",
    "\n",
    "        np.random.shuffle(transforms)\n",
    "        transform = Compose(transforms)\n",
    "\n",
    "        return transform\n",
    "\n",
    "    def __call__(self, img):\n",
    "        \"\"\"\n",
    "        Args:\n",
    "            img (PIL Image): Input image.\n",
    "\n",
    "        Returns:\n",
    "            PIL Image: Color jittered image.\n",
    "        \"\"\"\n",
    "        transform = self.get_params(self.brightness, self.contrast,\n",
    "                                    self.saturation, self.hue)\n",
    "        return transform(img)\n",
    "\n",
    "\n",
    "class RandomRotation(object):\n",
    "    \"\"\"Rotate the image by angle.\n",
    "\n",
    "    Args:\n",
    "        degrees (sequence or float or int): Range of degrees to select from.\n",
    "            If degrees is a number instead of sequence like (min, max), the range of degrees\n",
    "            will be (-degrees, +degrees).\n",
    "        resample ({PIL.Image.NEAREST, PIL.Image.BILINEAR, PIL.Image.BICUBIC}, optional):\n",
    "            An optional resampling filter.\n",
    "            See http://pillow.readthedocs.io/en/3.4.x/handbook/concepts.html#filters\n",
    "            If omitted, or if the image has mode \"1\" or \"P\", it is set to PIL.Image.NEAREST.\n",
    "        expand (bool, optional): Optional expansion flag.\n",
    "            If true, expands the output to make it large enough to hold the entire rotated image.\n",
    "            If false or omitted, make the output image the same size as the input image.\n",
    "            Note that the expand flag assumes rotation around the center and no translation.\n",
    "        center (2-tuple, optional): Optional center of rotation.\n",
    "            Origin is the upper left corner.\n",
    "            Default is the center of the image.\n",
    "    \"\"\"\n",
    "\n",
    "    def __init__(self, degrees, resample=False, expand=False, center=None):\n",
    "        if isinstance(degrees, numbers.Number):\n",
    "            if degrees < 0:\n",
    "                raise ValueError(\"If degrees is a single number, it must be positive.\")\n",
    "            self.degrees = (-degrees, degrees)\n",
    "        else:\n",
    "            if len(degrees) != 2:\n",
    "                raise ValueError(\"If degrees is a sequence, it must be of len 2.\")\n",
    "            self.degrees = degrees\n",
    "\n",
    "        self.resample = resample\n",
    "        self.expand = expand\n",
    "        self.center = center\n",
    "\n",
    "    @staticmethod\n",
    "    def get_params(degrees):\n",
    "        \"\"\"Get parameters for ``rotate`` for a random rotation.\n",
    "\n",
    "        Returns:\n",
    "            sequence: params to be passed to ``rotate`` for random rotation.\n",
    "        \"\"\"\n",
    "        angle = np.random.uniform(degrees[0], degrees[1])\n",
    "\n",
    "        return angle\n",
    "\n",
    "    def __call__(self, img):\n",
    "        \"\"\"\n",
    "            img (PIL Image): Image to be rotated.\n",
    "\n",
    "        Returns:\n",
    "            PIL Image: Rotated image.\n",
    "        \"\"\"\n",
    "\n",
    "        angle = self.get_params(self.degrees)\n",
    "\n",
    "        return F.rotate(img, angle, self.resample, self.expand, self.center)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.13"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
